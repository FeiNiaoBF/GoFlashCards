{
    "sourceFile": "db/sqlc/tags.sql.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1716989425495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1716989425495,
            "name": "Commit-0",
            "content": "// Code generated by sqlc. DO NOT EDIT.\n// versions:\n//   sqlc v1.26.0\n// source: tags.sql\n\npackage sqlc\n\nimport (\n\t\"context\"\n)\n\nconst createTags = `-- name: CreateTags :one\nINSERT INTO tags (name)\nVALUES ($1)\nRETURNING id, name\n`\n\nfunc (q *Queries) CreateTags(ctx context.Context, name string) (Tag, error) {\n\trow := q.db.QueryRow(ctx, createTags, name)\n\tvar i Tag\n\terr := row.Scan(&i.ID, &i.Name)\n\treturn i, err\n}\n\nconst deleteTags = `-- name: DeleteTags :exec\nDELETE FROM tags\nWHERE id = $1\n`\n\nfunc (q *Queries) DeleteTags(ctx context.Context, id int32) error {\n\t_, err := q.db.Exec(ctx, deleteTags, id)\n\treturn err\n}\n\nconst getAllTags = `-- name: GetAllTags :many\nSELECT id, name FROM tags\nORDER BY id\n`\n\nfunc (q *Queries) GetAllTags(ctx context.Context) ([]Tag, error) {\n\trows, err := q.db.Query(ctx, getAllTags)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tvar items []Tag\n\tfor rows.Next() {\n\t\tvar i Tag\n\t\tif err := rows.Scan(&i.ID, &i.Name); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\titems = append(items, i)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}\n\nconst getTags = `-- name: GetTags :one\nSELECT id, name FROM tags\nWHERE id = $1 LIMIT 1\n`\n\nfunc (q *Queries) GetTags(ctx context.Context, id int32) (Tag, error) {\n\trow := q.db.QueryRow(ctx, getTags, id)\n\tvar i Tag\n\terr := row.Scan(&i.ID, &i.Name)\n\treturn i, err\n}\n\nconst listTags = `-- name: ListTags :many\nSELECT id, name FROM tags\nORDER BY id\nLIMIT $1\nOFFSET $2\n`\n\ntype ListTagsParams struct {\n\tLimit  int32 `json:\"limit\"`\n\tOffset int32 `json:\"offset\"`\n}\n\nfunc (q *Queries) ListTags(ctx context.Context, arg ListTagsParams) ([]Tag, error) {\n\trows, err := q.db.Query(ctx, listTags, arg.Limit, arg.Offset)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tvar items []Tag\n\tfor rows.Next() {\n\t\tvar i Tag\n\t\tif err := rows.Scan(&i.ID, &i.Name); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\titems = append(items, i)\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}\n\nconst updateTags = `-- name: UpdateTags :one\nUPDATE tags\nSET name = $2\nWHERE id = $1\nRETURNING id, name\n`\n\ntype UpdateTagsParams struct {\n\tID   int32  `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\nfunc (q *Queries) UpdateTags(ctx context.Context, arg UpdateTagsParams) (Tag, error) {\n\trow := q.db.QueryRow(ctx, updateTags, arg.ID, arg.Name)\n\tvar i Tag\n\terr := row.Scan(&i.ID, &i.Name)\n\treturn i, err\n}\n"
        }
    ]
}